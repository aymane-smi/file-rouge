/**
 * Directive indicating which direction the Edge should point.
 * @group Attribute Types
 */
type Compass = 'n' | 'ne' | 'e' | 'se' | 's' | 'sw' | 'w' | 'nw' | 'c' | '_';
/**
 * A value specifying an empty string for resetting some values.
 * @group Attribute Types
 */
type Blank = '';
/**
 * A double with an optional prefix `'+'`.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/addDouble/ addDouble}
 * @group Attribute Types
 */
type AddDouble = `+${Double}`;
/**
 * Double-precision floating point number.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/double/ double}
 * @group Attribute Types
 */
type Double = number;
/**
 * Port Position
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/portPos/ portPos}
 * @group Attribute Types
 */
type PortPos = `${string}:${Compass}` | Compass;
/**
 * A colon-separated list of doubles: `"%f(:%f)*"` where each %f is a double.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/doubleList/ doubleList}
 * @group Attribute Types
 */
type DoubleList =
  | Double
  | `${Double}:${Double}`
  | `${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}`
  | `${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}:${Double}`;
/**
 * Integer number.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/int/ int}
 * @group Attribute Types
 */
type Int = number;
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/shape/ shape}
 * @group Attribute Types
 */
type Shape = string;
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/smoothType/ smoothType}
 * @group Attribute Types
 */
type SmoothType = 'none' | 'avg_dist' | 'graph_dist' | 'power_dist' | 'rng' | 'spring' | 'triangle';
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/splineType/ splineType}
 * @group Attribute Types
 */
type SplineType = SplineType.spline | string;
/** @hidden */
declare namespace SplineType {
  type prefix = endp | startp | `${endp}${startp}` | '';
  type spline = `${prefix}point ${triple}`;
  type triple = `${Point} ${Point} ${Point}`;
  type endp = `e,${Double},${Double} `;
  type startp = `s,${Double},${Double} `;
}
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/startType/ startType}
 * @group Attribute Types
 */
type StartType = `${StartType.style}${StartType.seed}`;
/** @hidden */
declare namespace StartType {
  type style = 'regular' | 'self' | 'random';
  type seed = number;
}
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/style/ style}
 * @group Attribute Types
 */
type Style =
  | Style.styleItem
  | `${Style.styleItem},${Style.styleItem}`
  | `${Style.styleItem},${Style.styleItem},${Style.styleItem}`
  | `${Style.styleItem},${Style.styleItem},${Style.styleItem},${Style.styleItem}`;
/** @hidden */
declare namespace Style {
  type styleItem =
    | 'dashed'
    | 'dotted'
    | 'solid'
    | 'invis'
    | 'bold'
    | 'tapered'
    | 'filled'
    | 'striped'
    | 'wedged'
    | 'diagonals'
    | 'rounded'
    | 'filled'
    | 'striped'
    | 'rounded'
    | 'radial';
}
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/viewPort/ viewPort}
 * @group Attribute Types
 */
type ViewPort = `${Double},${Double},${Double},${Double},${Double}` | `${Double},${Double},${Double},${string}`;
/**
 * list of strings separated by characters from the layersep attribute (by default, colons, tabs or spaces),
 * defining layer names and implicitly numbered 1,2,…
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/layerList/ layerList}
 * @group Attribute Types
 */
type LayerList = string;
/**
 * specifies a list of layers defined by the layers attribute.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/layerRange/ layerRange}
 * @group Attribute Types
 */
type LayerRange = string;
/**
 * String with Escape Sequences
 *
 * A string allowing escape sequences which are replaced according to the context.
 *
 * For node attributes, the substring `"\N"` is replaced by the name of the node,
 * and the substring `"\G"` by the name of the graph.
 *
 * For graph or cluster attributes, the substring `"\G"` is replaced by the name of the graph or cluster.
 *
 * For edge attributes, the substring `"\E"` is replaced by the name of the edge, the substring `"\G"` is replaced by the name of the graph or cluster,
 * and the substrings `"\T"` and `"\H"` by the names of the tail and head nodes,
 * respectively.
 *
 * The name of an edge is the string formed from the name of the tail node,
 * the appropriate edge operator (`"--"` or `"->"`) and the name of the head node.
 *
 * In all cases, the substring `"\L"` is replaced by the object's label attribute.
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/escString/ escString}
 * @group Attribute Types
 */
type EscString = string;
/**
 * @see {@link https://graphviz.org/doc/info/shapes.html#html HTML-Like Labels}
 * @group Attribute Types
 */
type HTMLLikeLabel = `<${string}>`;
/**
 * An escString or an HTML label.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/lblString/ lblString}
 * @group Attribute Types
 */
type LblString = HTMLLikeLabel | EscString;
/**
 * `"%f,%f('!')?"` representing the point (x,y).
 *
 * The optional `'!'` indicates the node position should not change (input-only).
 *
 * If dim=3, point may also have the format `"%f,%f,%f('!')?"` to represent the point (x,y,z).
 * @group Attribute Types
 */
type Point = Point.position | `${Point.position}!`;
/** @hidden */
declare namespace Point {
  type position =
    | `%${Double},%${Double}`
    | `%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double}`
    | `%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${Double},%${number}`;
}
/**
 * A point with an optional prefix `'+'`.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/addPoint/ addPoint}
 * @group Attribute Types
 */
type AddPoint = `+${Point}`;
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/pointList/ pointList}
 * @group Attribute Types
 */
type PointList = Point | `${Point} ${Point}` | `${Point} ${Point} ${Point}` | `${Point} ${Point} ${Point} ${Point}`;
/**
 * These specify the order in which nodes and edges are drawn in concrete output.
 *
 * - The default `"breadthfirst"` is the simplest, but when the graph layout does not avoid edge-node overlap, this mode will sometimes have edges drawn over nodes and sometimes on top of nodes.
 * - If the mode `"nodesfirst"` is chosen, all nodes are drawn first, followed by the edges. This guarantees an edge-node overlap will not be mistaken for an edge ending at a node.
 * - On the other hand, usually for aesthetic reasons, it may be desirable that all edges appear beneath nodes, even if the resulting drawing is ambiguous. This can be achieved by choosing `"edgesfirst"`.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/outputMode/ outputMode}
 * @group Attribute Types
 */
type OutputMode = 'breadthfirst' | 'nodesfirst' | 'edgesfirst';
/**
 * @see {@link https://graphviz.org/docs/attr-types/packMode/ packMode}
 * @group Attribute Types
 */
type PackMode = 'node' | 'clust' | 'graph' | `array${string}`;
/**
 * Using `"fast"` gives about a 2-4 times overall speedup compared with `"normal"`,
 * though layout quality can suffer a little.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/quadType/ quadType}
 * @group Attribute Types
 */
type QuadType = 'normal' | 'fast' | 'none';
/**
 * Rank Direction
 *
 * Corresponding to directed graphs drawn from top to bottom,
 * from left to right, from bottom to top, and from right to left, respectively.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/rankdir/ rankdir}
 * @group Attribute Types
 */
type Rankdir = 'TB' | 'LR' | 'BT' | 'RL';
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/rankType/ rankType}
 * @group Attribute Types
 */
type RankType = 'same' | 'min' | 'source' | 'max' | 'sink';
/**
 * `"%f,%f,%f,%f"`
 *
 * The rectangle `llx,lly,urx,ury` gives the coordinates, in points,
 * of the lower-left corner `(llx,lly)` and the upper-right corner `(urx,ury)`.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/rect/ rect}
 * @group Attribute Types
 */
type Rect = `${Double},${Double},${Double},${Double}`;
/**
 * The examples above show a set of commonly used arrow shapes.
 *
 * There is a grammar of arrow shapes which can be used to describe a collection of 3,111,696 arrow
 * combinations of the 42 variations of the primitive set of 11 arrows.
 *
 * @see {@link https://graphviz.org/docs/attr-types/arrowType/ arrowType}
 * @group Attribute Types
 */
type ArrowType = ArrowType.aname | `${ArrowType.aname}${ArrowType.aname}`;
/** @hidden */
declare namespace ArrowType {
  type shape = 'box' | 'crow' | 'curve' | 'icurve' | 'diamond' | 'dot' | 'inv' | 'none' | 'normal' | 'tee' | 'vee';
  type side = 'l' | 'r';
  type modifiers = side | 'o' | `o${side}`;
  type aname = shape | `${modifiers}${shape}`;
}
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/clusterMode/ clusterMode}
 * @group Attribute Types
 */
type ClusterMode = 'local' | 'global' | 'none';
/**
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/color/ color}
 * @group Attribute Types
 */
type Color = Color.RGB_RGBA | Color.HSV | Color.ColorName | number;
/** @hidden */
declare namespace Color {
  /**
   * `"#%2x%2x%2x"` Red-Green-Blue (RGB)
   *
   * `"#%2x%2x%2x%2x"` Red-Green-Blue-Alpha (RGBA)
   * @note A type that is too complicated to express in TypeScript.
   */
  type RGB_RGBA = `#${string}`;
  /**
   * Hue-Saturation-Value (HSV) 0.0 <= H,S,V <= 1.0
   */
  type HSV = `${number}+${number}+${number}`;
  /**
   * Color names are resolved in the context of a color scheme.
   *
   * Graphviz currently supports the X11 scheme, the SVG scheme, and the Brewer schemes, with X11 being the default.
   * @see {@link https://graphviz.org/doc/info/colors.html Color Names}
   */
  type ColorName =
    | 'aliceblue'
    | 'antiquewhite'
    | 'antiquewhite1'
    | 'antiquewhite2'
    | 'antiquewhite3'
    | 'antiquewhite4'
    | 'aqua'
    | 'aquamarine'
    | 'aquamarine1'
    | 'aquamarine2'
    | 'aquamarine3'
    | 'aquamarine4'
    | 'azure'
    | 'azure1'
    | 'azure2'
    | 'azure3'
    | 'azure4'
    | 'beige'
    | 'bisque'
    | 'bisque1'
    | 'bisque2'
    | 'bisque3'
    | 'bisque4'
    | 'black'
    | 'blanchedalmond'
    | 'blue'
    | 'blue1'
    | 'blue2'
    | 'blue3'
    | 'blue4'
    | 'blueviolet'
    | 'brown'
    | 'brown1'
    | 'brown2'
    | 'brown3'
    | 'brown4'
    | 'burlywood'
    | 'burlywood1'
    | 'burlywood2'
    | 'burlywood3'
    | 'burlywood4'
    | 'cadetblue'
    | 'cadetblue1'
    | 'cadetblue2'
    | 'cadetblue3'
    | 'cadetblue4'
    | 'chartreuse'
    | 'chartreuse1'
    | 'chartreuse2'
    | 'chartreuse3'
    | 'chartreuse4'
    | 'chocolate'
    | 'chocolate1'
    | 'chocolate2'
    | 'chocolate3'
    | 'chocolate4'
    | 'coral'
    | 'coral1'
    | 'coral2'
    | 'coral3'
    | 'coral4'
    | 'cornflowerblue'
    | 'cornsilk'
    | 'cornsilk1'
    | 'cornsilk2'
    | 'cornsilk3'
    | 'cornsilk4'
    | 'crimson'
    | 'cyan'
    | 'cyan1'
    | 'cyan2'
    | 'cyan3'
    | 'cyan4'
    | 'darkblue'
    | 'darkcyan'
    | 'darkgoldenrod'
    | 'darkgoldenrod1'
    | 'darkgoldenrod2'
    | 'darkgoldenrod3'
    | 'darkgoldenrod4'
    | 'darkgray'
    | 'darkgreen'
    | 'darkgrey'
    | 'darkkhaki'
    | 'darkmagenta'
    | 'darkolivegreen'
    | 'darkolivegreen1'
    | 'darkolivegreen2'
    | 'darkolivegreen3'
    | 'darkolivegreen4'
    | 'darkorange'
    | 'darkorange1'
    | 'darkorange2'
    | 'darkorange3'
    | 'darkorange4'
    | 'darkorchid'
    | 'darkorchid1'
    | 'darkorchid2'
    | 'darkorchid3'
    | 'darkorchid4'
    | 'darkred'
    | 'darksalmon'
    | 'darkseagreen'
    | 'darkseagreen1'
    | 'darkseagreen2'
    | 'darkseagreen3'
    | 'darkseagreen4'
    | 'darkslateblue'
    | 'darkslategray'
    | 'darkslategray1'
    | 'darkslategray2'
    | 'darkslategray3'
    | 'darkslategray4'
    | 'darkslategrey'
    | 'darkturquoise'
    | 'darkviolet'
    | 'deeppink'
    | 'deeppink1'
    | 'deeppink2'
    | 'deeppink3'
    | 'deeppink4'
    | 'deepskyblue'
    | 'deepskyblue1'
    | 'deepskyblue2'
    | 'deepskyblue3'
    | 'deepskyblue4'
    | 'dimgray'
    | 'dimgrey'
    | 'dodgerblue'
    | 'dodgerblue1'
    | 'dodgerblue2'
    | 'dodgerblue3'
    | 'dodgerblue4'
    | 'firebrick'
    | 'firebrick1'
    | 'firebrick2'
    | 'firebrick3'
    | 'firebrick4'
    | 'floralwhite'
    | 'forestgreen'
    | 'fuchsia'
    | 'gainsboro'
    | 'ghostwhite'
    | 'gold'
    | 'gold1'
    | 'gold2'
    | 'gold3'
    | 'gold4'
    | 'goldenrod'
    | 'goldenrod1'
    | 'goldenrod2'
    | 'goldenrod3'
    | 'goldenrod4'
    | 'gray'
    | 'gray0'
    | 'gray1'
    | 'gray10'
    | 'gray100'
    | 'gray11'
    | 'gray12'
    | 'gray13'
    | 'gray14'
    | 'gray15'
    | 'gray16'
    | 'gray17'
    | 'gray18'
    | 'gray19'
    | 'gray2'
    | 'gray20'
    | 'gray21'
    | 'gray22'
    | 'gray23'
    | 'gray24'
    | 'gray25'
    | 'gray26'
    | 'gray27'
    | 'gray28'
    | 'gray29'
    | 'gray3'
    | 'gray30'
    | 'gray31'
    | 'gray32'
    | 'gray33'
    | 'gray34'
    | 'gray35'
    | 'gray36'
    | 'gray37'
    | 'gray38'
    | 'gray39'
    | 'gray4'
    | 'gray40'
    | 'gray41'
    | 'gray42'
    | 'gray43'
    | 'gray44'
    | 'gray45'
    | 'gray46'
    | 'gray47'
    | 'gray48'
    | 'gray49'
    | 'gray5'
    | 'gray50'
    | 'gray51'
    | 'gray52'
    | 'gray53'
    | 'gray54'
    | 'gray55'
    | 'gray56'
    | 'gray57'
    | 'gray58'
    | 'gray59'
    | 'gray6'
    | 'gray60'
    | 'gray61'
    | 'gray62'
    | 'gray63'
    | 'gray64'
    | 'gray65'
    | 'gray66'
    | 'gray67'
    | 'gray68'
    | 'gray69'
    | 'gray7'
    | 'gray70'
    | 'gray71'
    | 'gray72'
    | 'gray73'
    | 'gray74'
    | 'gray75'
    | 'gray76'
    | 'gray77'
    | 'gray78'
    | 'gray79'
    | 'gray8'
    | 'gray80'
    | 'gray81'
    | 'gray82'
    | 'gray83'
    | 'gray84'
    | 'gray85'
    | 'gray86'
    | 'gray87'
    | 'gray88'
    | 'gray89'
    | 'gray9'
    | 'gray90'
    | 'gray91'
    | 'gray92'
    | 'gray93'
    | 'gray94'
    | 'gray95'
    | 'gray96'
    | 'gray97'
    | 'gray98'
    | 'gray99'
    | 'green'
    | 'green1'
    | 'green2'
    | 'green3'
    | 'green4'
    | 'greenyellow'
    | 'grey'
    | 'grey0'
    | 'grey1'
    | 'grey10'
    | 'grey100'
    | 'grey11'
    | 'grey12'
    | 'grey13'
    | 'grey14'
    | 'grey15'
    | 'grey16'
    | 'grey17'
    | 'grey18'
    | 'grey19'
    | 'grey2'
    | 'grey20'
    | 'grey21'
    | 'grey22'
    | 'grey23'
    | 'grey24'
    | 'grey25'
    | 'grey26'
    | 'grey27'
    | 'grey28'
    | 'grey29'
    | 'grey3'
    | 'grey30'
    | 'grey31'
    | 'grey32'
    | 'grey33'
    | 'grey34'
    | 'grey35'
    | 'grey36'
    | 'grey37'
    | 'grey38'
    | 'grey39'
    | 'grey4'
    | 'grey40'
    | 'grey41'
    | 'grey42'
    | 'grey43'
    | 'grey44'
    | 'grey45'
    | 'grey46'
    | 'grey47'
    | 'grey48'
    | 'grey49'
    | 'grey5'
    | 'grey50'
    | 'grey51'
    | 'grey52'
    | 'grey53'
    | 'grey54'
    | 'grey55'
    | 'grey56'
    | 'grey57'
    | 'grey58'
    | 'grey59'
    | 'grey6'
    | 'grey60'
    | 'grey61'
    | 'grey62'
    | 'grey63'
    | 'grey64'
    | 'grey65'
    | 'grey66'
    | 'grey67'
    | 'grey68'
    | 'grey69'
    | 'grey7'
    | 'grey70'
    | 'grey71'
    | 'grey72'
    | 'grey73'
    | 'grey74'
    | 'grey75'
    | 'grey76'
    | 'grey77'
    | 'grey78'
    | 'grey79'
    | 'grey8'
    | 'grey80'
    | 'grey81'
    | 'grey82'
    | 'grey83'
    | 'grey84'
    | 'grey85'
    | 'grey86'
    | 'grey87'
    | 'grey88'
    | 'grey89'
    | 'grey9'
    | 'grey90'
    | 'grey91'
    | 'grey92'
    | 'grey93'
    | 'grey94'
    | 'grey95'
    | 'grey96'
    | 'grey97'
    | 'grey98'
    | 'grey99'
    | 'honeydew'
    | 'honeydew1'
    | 'honeydew2'
    | 'honeydew3'
    | 'honeydew4'
    | 'hotpink'
    | 'hotpink1'
    | 'hotpink2'
    | 'hotpink3'
    | 'hotpink4'
    | 'indianred'
    | 'indianred1'
    | 'indianred2'
    | 'indianred3'
    | 'indianred4'
    | 'indigo'
    | 'invis'
    | 'ivory'
    | 'ivory1'
    | 'ivory2'
    | 'ivory3'
    | 'ivory4'
    | 'khaki'
    | 'khaki1'
    | 'khaki2'
    | 'khaki3'
    | 'khaki4'
    | 'lavender'
    | 'lavenderblush'
    | 'lavenderblush1'
    | 'lavenderblush2'
    | 'lavenderblush3'
    | 'lavenderblush4'
    | 'lawngreen'
    | 'lemonchiffon'
    | 'lemonchiffon1'
    | 'lemonchiffon2'
    | 'lemonchiffon3'
    | 'lemonchiffon4'
    | 'lightblue'
    | 'lightblue1'
    | 'lightblue2'
    | 'lightblue3'
    | 'lightblue4'
    | 'lightcoral'
    | 'lightcyan'
    | 'lightcyan1'
    | 'lightcyan2'
    | 'lightcyan3'
    | 'lightcyan4'
    | 'lightgoldenrod'
    | 'lightgoldenrod1'
    | 'lightgoldenrod2'
    | 'lightgoldenrod3'
    | 'lightgoldenrod4'
    | 'lightgoldenrodyellow'
    | 'lightgray'
    | 'lightgreen'
    | 'lightgrey'
    | 'lightpink'
    | 'lightpink1'
    | 'lightpink2'
    | 'lightpink3'
    | 'lightpink4'
    | 'lightsalmon'
    | 'lightsalmon1'
    | 'lightsalmon2'
    | 'lightsalmon3'
    | 'lightsalmon4'
    | 'lightseagreen'
    | 'lightskyblue'
    | 'lightskyblue1'
    | 'lightskyblue2'
    | 'lightskyblue3'
    | 'lightskyblue4'
    | 'lightslateblue'
    | 'lightslategray'
    | 'lightslategrey'
    | 'lightsteelblue'
    | 'lightsteelblue1'
    | 'lightsteelblue2'
    | 'lightsteelblue3'
    | 'lightsteelblue4'
    | 'lightyellow'
    | 'lightyellow1'
    | 'lightyellow2'
    | 'lightyellow3'
    | 'lightyellow4'
    | 'lime'
    | 'limegreen'
    | 'linen'
    | 'magenta'
    | 'magenta1'
    | 'magenta2'
    | 'magenta3'
    | 'magenta4'
    | 'maroon'
    | 'maroon1'
    | 'maroon2'
    | 'maroon3'
    | 'maroon4'
    | 'mediumaquamarine'
    | 'mediumblue'
    | 'mediumorchid'
    | 'mediumorchid1'
    | 'mediumorchid2'
    | 'mediumorchid3'
    | 'mediumorchid4'
    | 'mediumpurple'
    | 'mediumpurple1'
    | 'mediumpurple2'
    | 'mediumpurple3'
    | 'mediumpurple4'
    | 'mediumseagreen'
    | 'mediumslateblue'
    | 'mediumspringgreen'
    | 'mediumturquoise'
    | 'mediumvioletred'
    | 'midnightblue'
    | 'mintcream'
    | 'mistyrose'
    | 'mistyrose1'
    | 'mistyrose2'
    | 'mistyrose3'
    | 'mistyrose4'
    | 'moccasin'
    | 'navajowhite'
    | 'navajowhite1'
    | 'navajowhite2'
    | 'navajowhite3'
    | 'navajowhite4'
    | 'navy'
    | 'navyblue'
    | 'none'
    | 'oldlace'
    | 'olive'
    | 'olivedrab'
    | 'olivedrab1'
    | 'olivedrab2'
    | 'olivedrab3'
    | 'olivedrab4'
    | 'orange'
    | 'orange1'
    | 'orange2'
    | 'orange3'
    | 'orange4'
    | 'orangered'
    | 'orangered1'
    | 'orangered2'
    | 'orangered3'
    | 'orangered4'
    | 'orchid'
    | 'orchid1'
    | 'orchid2'
    | 'orchid3'
    | 'orchid4'
    | 'palegoldenrod'
    | 'palegreen'
    | 'palegreen1'
    | 'palegreen2'
    | 'palegreen3'
    | 'palegreen4'
    | 'paleturquoise'
    | 'paleturquoise1'
    | 'paleturquoise2'
    | 'paleturquoise3'
    | 'paleturquoise4'
    | 'palevioletred'
    | 'palevioletred1'
    | 'palevioletred2'
    | 'palevioletred3'
    | 'palevioletred4'
    | 'papayawhip'
    | 'peachpuff'
    | 'peachpuff1'
    | 'peachpuff2'
    | 'peachpuff3'
    | 'peachpuff4'
    | 'peru'
    | 'pink'
    | 'pink1'
    | 'pink2'
    | 'pink3'
    | 'pink4'
    | 'plum'
    | 'plum1'
    | 'plum2'
    | 'plum3'
    | 'plum4'
    | 'powderblue'
    | 'purple'
    | 'purple1'
    | 'purple2'
    | 'purple3'
    | 'purple4'
    | 'rebeccapurple'
    | 'red'
    | 'red1'
    | 'red2'
    | 'red3'
    | 'red4'
    | 'rosybrown'
    | 'rosybrown1'
    | 'rosybrown2'
    | 'rosybrown3'
    | 'rosybrown4'
    | 'royalblue'
    | 'royalblue1'
    | 'royalblue2'
    | 'royalblue3'
    | 'royalblue4'
    | 'saddlebrown'
    | 'salmon'
    | 'salmon1'
    | 'salmon2'
    | 'salmon3'
    | 'salmon4'
    | 'sandybrown'
    | 'seagreen'
    | 'seagreen1'
    | 'seagreen2'
    | 'seagreen3'
    | 'seagreen4'
    | 'seashell'
    | 'seashell1'
    | 'seashell2'
    | 'seashell3'
    | 'seashell4'
    | 'sienna'
    | 'sienna1'
    | 'sienna2'
    | 'sienna3'
    | 'sienna4'
    | 'silver'
    | 'skyblue'
    | 'skyblue1'
    | 'skyblue2'
    | 'skyblue3'
    | 'skyblue4'
    | 'slateblue'
    | 'slateblue1'
    | 'slateblue2'
    | 'slateblue3'
    | 'slateblue4'
    | 'slategray'
    | 'slategray1'
    | 'slategray2'
    | 'slategray3'
    | 'slategray4'
    | 'slategrey'
    | 'snow'
    | 'snow1'
    | 'snow2'
    | 'snow3'
    | 'snow4'
    | 'springgreen'
    | 'springgreen1'
    | 'springgreen2'
    | 'springgreen3'
    | 'springgreen4'
    | 'steelblue'
    | 'steelblue1'
    | 'steelblue2'
    | 'steelblue3'
    | 'steelblue4'
    | 'tan'
    | 'tan1'
    | 'tan2'
    | 'tan3'
    | 'tan4'
    | 'teal'
    | 'thistle'
    | 'thistle1'
    | 'thistle2'
    | 'thistle3'
    | 'thistle4'
    | 'tomato'
    | 'tomato1'
    | 'tomato2'
    | 'tomato3'
    | 'tomato4'
    | 'transparent'
    | 'turquoise'
    | 'turquoise1'
    | 'turquoise2'
    | 'turquoise3'
    | 'turquoise4'
    | 'violet'
    | 'violetred'
    | 'violetred1'
    | 'violetred2'
    | 'violetred3'
    | 'violetred4'
    | 'webgray'
    | 'webgreen'
    | 'webgrey'
    | 'webmaroon'
    | 'webpurple'
    | 'wheat'
    | 'wheat1'
    | 'wheat2'
    | 'wheat3'
    | 'wheat4'
    | 'white'
    | 'whitesmoke'
    | 'x11gray'
    | 'x11green'
    | 'x11grey'
    | 'x11maroon'
    | 'x11purple'
    | 'yellow'
    | 'yellow1'
    | 'yellow2'
    | 'yellow3'
    | 'yellow4'
    | 'yellowgreen'
    | 'aliceblue'
    | 'antiquewhite'
    | 'aqua'
    | 'aquamarine'
    | 'azure'
    | 'beige'
    | 'bisque'
    | 'black'
    | 'blanchedalmond'
    | 'blue'
    | 'blueviolet'
    | 'brown'
    | 'burlywood'
    | 'cadetblue'
    | 'chartreuse'
    | 'chocolate'
    | 'coral'
    | 'cornflowerblue'
    | 'cornsilk'
    | 'crimson'
    | 'cyan'
    | 'darkblue'
    | 'darkcyan'
    | 'darkgoldenrod'
    | 'darkgray'
    | 'darkgreen'
    | 'darkgrey'
    | 'darkkhaki'
    | 'darkmagenta'
    | 'darkolivegreen'
    | 'darkorange'
    | 'darkorchid'
    | 'darkred'
    | 'darksalmon'
    | 'darkseagreen'
    | 'darkslateblue'
    | 'darkslategray'
    | 'darkslategrey'
    | 'darkturquoise'
    | 'darkviolet'
    | 'deeppink'
    | 'deepskyblue'
    | 'dimgray'
    | 'dimgrey'
    | 'dodgerblue'
    | 'firebrick'
    | 'floralwhite'
    | 'forestgreen'
    | 'fuchsia'
    | 'gainsboro'
    | 'ghostwhite'
    | 'gold'
    | 'goldenrod'
    | 'gray'
    | 'grey'
    | 'green'
    | 'greenyellow'
    | 'honeydew'
    | 'hotpink'
    | 'indianred'
    | 'indigo'
    | 'ivory'
    | 'khaki'
    | 'lavender'
    | 'lavenderblush'
    | 'lawngreen'
    | 'lemonchiffon'
    | 'lightblue'
    | 'lightcoral'
    | 'lightcyan'
    | 'lightgoldenrodyellow'
    | 'lightgray'
    | 'lightgreen'
    | 'lightgrey'
    | 'lightpink'
    | 'lightsalmon'
    | 'lightseagreen'
    | 'lightskyblue'
    | 'lightslategray'
    | 'lightslategrey'
    | 'lightsteelblue'
    | 'lightyellow'
    | 'lime'
    | 'limegreen'
    | 'linen'
    | 'magenta'
    | 'maroon'
    | 'mediumaquamarine'
    | 'mediumblue'
    | 'mediumorchid'
    | 'mediumpurple'
    | 'mediumseagreen'
    | 'mediumslateblue'
    | 'mediumspringgreen'
    | 'mediumturquoise'
    | 'mediumvioletred'
    | 'midnightblue'
    | 'mintcream'
    | 'mistyrose'
    | 'moccasin'
    | 'navajowhite'
    | 'navy'
    | 'oldlace'
    | 'olive'
    | 'olivedrab'
    | 'orange'
    | 'orangered'
    | 'orchid'
    | 'palegoldenrod'
    | 'palegreen'
    | 'paleturquoise'
    | 'palevioletred'
    | 'papayawhip'
    | 'peachpuff'
    | 'peru'
    | 'pink'
    | 'plum'
    | 'powderblue'
    | 'purple'
    | 'red'
    | 'rosybrown'
    | 'royalblue'
    | 'saddlebrown'
    | 'salmon'
    | 'sandybrown'
    | 'seagreen'
    | 'seashell'
    | 'sienna'
    | 'silver'
    | 'skyblue'
    | 'slateblue'
    | 'slategray'
    | 'slategrey'
    | 'snow'
    | 'springgreen'
    | 'steelblue'
    | 'tan'
    | 'teal'
    | 'thistle'
    | 'tomato'
    | 'turquoise'
    | 'violet'
    | 'wheat'
    | 'white'
    | 'whitesmoke'
    | 'yellow'
    | 'yellowgreen';
}
/**
 * A colon-separated list of weighted color values: WC(:WC)* where each WC has the form C(;F)? with C a color value and the optional F a floating-point number, 0 ≤ F ≤ 1.
 *
 * The sum of the floating-point numbers in a colorList must sum to at most 1.
 *
 * @note A type that is too complicated to express in TypeScript.
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/colorList/}
 * @group Attribute Types
 */
type ColorList = string;
/**
 * Direction Type
 *
 * @see {@link https://graphviz.gitlab.io/docs/attr-types/dirType/ dirType}
 * @group Attribute Types
 */
type DirType = 'forward' | 'back' | 'both' | 'none';
/**
 * Page Direction
 *
 * @see {@link https://graphviz.org/docs/attr-types/pagedir/ pagedir}
 * @group Attribute Types
 */
type Pagedir = `${Pagedir.TB}${Pagedir.RL}`;
/** @hidden */
declare namespace Pagedir {
  type TB = 'T' | 'B';
  type RL = 'R' | 'L';
}

/**
 * Attribute types available for edges.
 * @group Attribute
 */
type EdgeAttributeKey =
  | 'URL'
  | 'arrowhead'
  | 'arrowsize'
  | 'arrowtail'
  | 'color'
  | 'colorscheme'
  | 'comment'
  | 'constraint'
  | 'decorate'
  | 'dir'
  | 'edgeURL'
  | 'edgehref'
  | 'edgetarget'
  | 'edgetooltip'
  | 'fillcolor'
  | 'fontcolor'
  | 'fontname'
  | 'fontsize'
  | 'headURL'
  | 'head_lp'
  | 'headclip'
  | 'headhref'
  | 'headlabel'
  | 'headport'
  | 'headtarget'
  | 'headtooltip'
  | 'href'
  | 'id'
  | 'label'
  | 'labelURL'
  | 'labelangle'
  | 'labeldistance'
  | 'labelfloat'
  | 'labelfontcolor'
  | 'labelfontname'
  | 'labelfontsize'
  | 'labelhref'
  | 'labeltarget'
  | 'labeltooltip'
  | 'layer'
  | 'len'
  | 'lhead'
  | 'lp'
  | 'ltail'
  | 'minlen'
  | 'nojustify'
  | 'penwidth'
  | 'pos'
  | 'samehead'
  | 'sametail'
  | 'showboxes'
  | 'style'
  | 'tailURL'
  | 'tail_lp'
  | 'tailclip'
  | 'tailhref'
  | 'taillabel'
  | 'tailport'
  | 'tailtarget'
  | 'tailtooltip'
  | 'target'
  | 'tooltip'
  | 'weight'
  | 'xlabel'
  | 'xlp'
  | 'class';
/**
 * Attribute types available for nodes.
 * @group Attribute
 */
type NodeAttributeKey =
  | 'URL'
  | 'area'
  | 'color'
  | 'colorscheme'
  | 'comment'
  | 'distortion'
  | 'fillcolor'
  | 'fixedsize'
  | 'fontcolor'
  | 'fontname'
  | 'fontsize'
  | 'gradientangle'
  | 'group'
  | 'height'
  | 'href'
  | 'id'
  | 'image'
  | 'imagepos'
  | 'imagescale'
  | 'label'
  | 'labelloc'
  | 'layer'
  | 'margin'
  | 'nojustify'
  | 'ordering'
  | 'orientation'
  | 'penwidth'
  | 'peripheries'
  | 'pin'
  | 'pos'
  | 'rects'
  | 'regular'
  | 'root'
  | 'samplepoints'
  | 'shape'
  | 'shapefile'
  | 'showboxes'
  | 'sides'
  | 'skew'
  | 'sortv'
  | 'style'
  | 'target'
  | 'tooltip'
  | 'vertices'
  | 'width'
  | 'xlabel'
  | 'xlp'
  | 'z'
  | 'class';
/**
 * Attribute types available for graph.
 * @group Attribute
 */
type GraphAttributeKey =
  | 'Damping'
  | 'K'
  | 'URL'
  | '_background'
  | 'bb'
  | 'bgcolor'
  | 'center'
  | 'charset'
  | 'clusterrank'
  | 'colorscheme'
  | 'comment'
  | 'compound'
  | 'concentrate'
  | 'defaultdist'
  | 'dim'
  | 'dimen'
  | 'diredgeconstraints'
  | 'dpi'
  | 'epsilon'
  | 'esep'
  | 'fontcolor'
  | 'fontname'
  | 'fontnames'
  | 'fontpath'
  | 'fontsize'
  | 'forcelabels'
  | 'gradientangle'
  | 'href'
  | 'id'
  | 'imagepath'
  | 'inputscale'
  | 'label'
  | 'label_scheme'
  | 'labeljust'
  | 'labelloc'
  | 'landscape'
  | 'layerlistsep'
  | 'layers'
  | 'layerselect'
  | 'layersep'
  | 'layout'
  | 'levels'
  | 'levelsgap'
  | 'lheight'
  | 'lp'
  | 'lwidth'
  | 'margin'
  | 'maxiter'
  | 'mclimit'
  | 'mindist'
  | 'mode'
  | 'model'
  | 'mosek'
  | 'newrank'
  | 'nodesep'
  | 'nojustify'
  | 'normalize'
  | 'notranslate'
  | 'nslimit'
  | 'nslimit1'
  | 'ordering'
  | 'orientation'
  | 'outputorder'
  | 'overlap'
  | 'overlap_scaling'
  | 'overlap_shrink'
  | 'pack'
  | 'packmode'
  | 'pad'
  | 'page'
  | 'pagedir'
  | 'quadtree'
  | 'quantum'
  | 'rankdir'
  | 'ranksep'
  | 'ratio'
  | 'remincross'
  | 'repulsiveforce'
  | 'resolution'
  | 'root'
  | 'rotate'
  | 'rotation'
  | 'scale'
  | 'searchsize'
  | 'sep'
  | 'showboxes'
  | 'size'
  | 'smoothing'
  | 'sortv'
  | 'splines'
  | 'start'
  | 'style'
  | 'stylesheet'
  | 'target'
  | 'truecolor'
  | 'viewport'
  | 'voro_margin'
  | 'xdotversion'
  | 'class';
/**
 * Attribute types available for subgraph.
 * @group Attribute
 */
type SubgraphAttributeKey = 'rank';
/**
 * Attribute types available for cluster subgraph.
 * @group Attribute
 */
type ClusterSubgraphAttributeKey =
  | 'K'
  | 'URL'
  | 'area'
  | 'bgcolor'
  | 'color'
  | 'colorscheme'
  | 'fillcolor'
  | 'fontcolor'
  | 'fontname'
  | 'fontsize'
  | 'gradientangle'
  | 'href'
  | 'id'
  | 'label'
  | 'labeljust'
  | 'labelloc'
  | 'layer'
  | 'lheight'
  | 'lp'
  | 'lwidth'
  | 'margin'
  | 'nojustify'
  | 'pencolor'
  | 'penwidth'
  | 'peripheries'
  | 'sortv'
  | 'style'
  | 'target'
  | 'tooltip'
  | 'class';
/**
 * Attribute types.
 * @group Attribute
 */
type AttributeKey =
  | NodeAttributeKey
  | EdgeAttributeKey
  | GraphAttributeKey
  | SubgraphAttributeKey
  | ClusterSubgraphAttributeKey;

/**
 * KeyValueMapping is an interface that defines a set of attributes that can be used to configure a graph.
 */
interface KeyValueMapping {
  _background: string;
  area: Double;
  arrowhead: ArrowType;
  arrowsize: Double;
  arrowtail: ArrowType;
  bb: Rect;
  bgcolor: Color | ColorList;
  center: boolean;
  charset: string;
  class: string;
  clusterrank: ClusterMode;
  color: Color | ColorList;
  colorscheme: string;
  comment: string;
  compound: boolean;
  concentrate: boolean;
  constraint: boolean;
  Damping: Double;
  decorate: boolean;
  defaultdist: Double;
  dim: Int;
  dimen: Int;
  dir: DirType;
  diredgeconstraints: string | boolean;
  distortion: Double;
  dpi: Double;
  edgehref: EscString;
  edgetarget: EscString;
  edgetooltip: EscString;
  edgeURL: EscString;
  epsilon: Double;
  esep: AddDouble | AddPoint;
  fillcolor: Color | ColorList;
  fixedsize: boolean | string;
  fontcolor: Color;
  fontname: string;
  fontnames: string;
  fontpath: string;
  fontsize: Double;
  forcelabels: boolean;
  gradientangle: Blank | Int;
  group: string;
  head_lp: Point;
  headclip: boolean;
  headhref: EscString;
  headlabel: LblString;
  headport: PortPos;
  headtarget: EscString;
  headtooltip: EscString;
  headURL: EscString;
  height: Blank | Double;
  href: EscString;
  id: EscString;
  image: string;
  imagepath: string;
  imagepos: string;
  imagescale: string | boolean;
  inputscale: Double;
  K: Double;
  label: LblString;
  label_scheme: Int;
  labelangle: Double;
  labeldistance: Double;
  labelfloat: boolean;
  labelfontcolor: Color;
  labelfontname: string;
  labelfontsize: Double;
  labelhref: EscString;
  labeljust: string;
  labelloc: string;
  labeltarget: EscString;
  labeltooltip: EscString;
  labelURL: EscString;
  landscape: boolean;
  layer: LayerRange;
  layerlistsep: string;
  layers: LayerList;
  layerselect: LayerRange;
  layersep: string;
  layout: string;
  len: Double;
  levels: Int;
  levelsgap: Double;
  lhead: string;
  lheight: Double;
  lp: Point;
  ltail: string;
  lwidth: Double;
  margin: Double | Point;
  maxiter: Int;
  mclimit: Double;
  mindist: Double;
  minlen: Int;
  mode: string;
  model: string;
  mosek: boolean;
  newrank: boolean;
  nodesep: Double;
  nojustify: boolean;
  normalize: Double | boolean;
  notranslate: boolean;
  nslimit: Double;
  nslimit1: Double;
  ordering: string;
  orientation: string | Double;
  outputorder: OutputMode;
  overlap: string | boolean;
  overlap_scaling: Double;
  overlap_shrink: boolean;
  pack: boolean | Int;
  packmode: PackMode;
  pad: Double | Point;
  page: Double | Point;
  pagedir: Pagedir;
  pencolor: Color;
  penwidth: Double;
  peripheries: Int;
  pin: boolean;
  pos: Point | SplineType;
  quadtree: QuadType | boolean;
  quantum: Double;
  rank: RankType;
  rankdir: Rankdir;
  ranksep: Double | DoubleList;
  ratio: Double | string;
  rects: Rect;
  regular: boolean;
  remincross: boolean;
  repulsiveforce: Double;
  resolution: Double;
  root: string | boolean;
  rotate: Int;
  rotation: Double;
  samehead: string;
  sametail: string;
  samplepoints: Int;
  scale: Double | Point;
  searchsize: Int;
  sep: AddDouble | AddPoint;
  shape: Shape;
  shapefile: string;
  showboxes: Int;
  sides: Int;
  size: Double | Point;
  skew: Double;
  smoothing: SmoothType;
  sortv: Int;
  splines: boolean | string;
  start: Blank | StartType;
  style: Blank | Style;
  stylesheet: string;
  tail_lp: string;
  tailclip: Point;
  tailhref: EscString;
  taillabel: LblString;
  tailport: PortPos;
  tailtarget: EscString;
  tailtooltip: EscString;
  tailURL: EscString;
  target: EscString | string;
  tooltip: EscString;
  truecolor: boolean;
  URL: EscString;
  vertices: PointList;
  viewport: Blank | ViewPort;
  voro_margin: Double;
  weight: Int | Double;
  width: Double;
  xdotversion: string;
  xlabel: LblString;
  xlp: Point;
  z: Blank | Double;
}
/**
 * This type represents an Attribute, which is a key-value mapping of an {@link AttributeKey} to a value.
 *
 * @param T The {@link AttributeKey} to be mapped to a value.
 * @group Attribute
 */
type Attribute<T extends AttributeKey> = KeyValueMapping[T];

/**
 * @group Models Context
 * @beta
 */
interface ModelsContext {
  Graph: RootGraphConstructor;
  Digraph: RootGraphConstructor;
  Subgraph: SubgraphConstructor;
  Node: NodeConstructor;
  Edge: EdgeConstructor;
}
/**
 * @group Models Context
 * @alpha
 */
declare const RootModelsContext: ModelsContext;
/**
 * @group Models Context
 * @alpha
 */
declare function createModelsContext(models: Partial<ModelsContext>): ModelsContext;

/**
 * ASTType is an enumeration of the different types of nodes that can be found in an AST(Abstract Syntax Tree ).
 * @group Models
 */
type ASTType =
  | 'Literal'
  | 'Dot'
  | 'Graph'
  | 'Attribute'
  | 'Comment'
  | 'AttributeList'
  | 'NodeRef'
  | 'NodeRefGroup'
  | 'Edge'
  | 'Node'
  | 'Subgraph';
/**
 * Objects that can be Edge destinations satisfy this interface.
 * @group Models
 */
type NodeRef = NodeModel | ForwardRefNode;
/**
 * @group Models
 */
type NodeRefGroup = NodeRef[];
/**
 * string or an object implementing EdgeTarget.
 * @group Models
 */
type NodeRefLike = NodeRef | string;
/**
 * @group Models
 */
type NodeRefGroupLike = NodeRefLike[];
/**
 * @group Models
 */
type EdgeTarget = NodeRef | NodeRefGroup;
/**
 * @group Models
 */
type EdgeTargetLike = NodeRefLike | NodeRefGroupLike;
/**
 * @group Models
 */
type EdgeTargetTuple = [from: EdgeTarget, to: EdgeTarget, ...rest: EdgeTarget[]];
/**
 * @group Models
 */
type EdgeTargetLikeTuple = [from: EdgeTargetLike, to: EdgeTargetLike, ...rest: EdgeTargetLike[]];
/**
 * An objects of attribute key/value pairs.
 * @group Models
 */
type AttributesObject<T extends AttributeKey> = {
  [K in T]?: Attribute<K>;
};
/**
 * @group Models
 */
type AttributeValue = Attribute<AttributeKey>;
/**
 * An array of attribute key/value tuple.
 * @group Models
 */
type AttributesEntities<T extends AttributeKey> = readonly [T, Attribute<T>][];
/**
 * Attribute object that can be set to Edge.
 * @group Models
 */
type EdgeAttributesObject = AttributesObject<EdgeAttributeKey>;
/**
 * Attribute object that can be set to Node.
 * @group Models
 */
type NodeAttributesObject = AttributesObject<NodeAttributeKey>;
/**
 * Attribute object that can be set to Graph.
 * @group Models
 */
type GraphAttributesObject = AttributesObject<GraphAttributeKey>;
/**
 * Attribute object that can be set to Subgraph.
 * @group Models
 */
type SubgraphAttributesObject = AttributesObject<ClusterSubgraphAttributeKey | SubgraphAttributeKey>;
/**
 * @group Models
 */
type DotObjectType = 'AttributeList' | 'Node' | 'Edge' | 'Subgraph' | 'Graph';
/**
 * DotObjectModel is an interface that defines a generic type for a {@link DotObjectType}.
 *
 * @template T The type of the {@link DotObjectType}.
 * @group Models
 */
interface DotObjectModel<T extends DotObjectType = DotObjectType> {
  /**
   * The type of the DotObjectType.
   */
  $$type: T;
}
/**
 * @group Models
 */
interface HasComment {
  /** Comments to include when outputting with toDot. */
  comment?: string;
}
/**
 * @group Models
 */
interface HasAttributes<T extends AttributeKey> {
  readonly attributes: AttributesGroupModel<T>;
}
/**
 * @group Models
 */
interface ForwardRefNode extends Partial<Port> {
  readonly id: string;
}
/**
 * DOT object with the property
 * that attributes can be held as a set of keys and values.
 *
 * @typeParam T - The attribute keys to set DOT object.
 * @group Models
 */
interface Attributes<T extends AttributeKey> {
  /** Size of the set of keys and values held by the DOT object. */
  readonly size: number;
  /** The key/value tuples of the object attributes. */
  readonly values: ReadonlyArray<[T, Attribute<T>]>;
  /**
   * Get the value of an attribute by a DOT object by specifying its key.
   *
   * If the value corresponding to the key does not exist, undefined is returned.
   */
  get(key: T): Attribute<T> | undefined;
  /** Set a value, by specifying the key of the attributes in the DOT object. */
  set(key: T, value: Attribute<T>): void;
  /**
   * Apply keys and values that can be specified for DOT objects collectively.
   *
   * @param attributes - An array of objects or tuples of attribute key/value pairs.
   */
  apply(attributes: AttributesObject<T> | AttributesEntities<T>): void;
  /** Delete the value of an attribute from a DOT object by specifying a key. */
  delete(key: T): void;
  /** Delete all attributes specified for the DOT object. */
  clear(): void;
}
/**
 * @group Models
 */
interface AttributesGroupModel<T extends AttributeKey> extends Attributes<T>, HasComment {}
/**
 * @group Models
 */
type AttributeListKind = 'Graph' | 'Edge' | 'Node';
/**
 * A list object of attributes commonly specified for nodes, subgraphs, and edges
 * under graph and subgraph.
 *
 * @typeParam K - The type of object is being specified.
 * @typeParam T - The attribute keys to set DOT object.
 * @group Models
 */
interface AttributeListModel<K extends AttributeListKind = AttributeListKind, T extends AttributeKey = AttributeKey>
  extends Attributes<T>,
    HasComment,
    DotObjectModel<'AttributeList'> {
  $$kind: K;
}
/**
 * Port on an edge node.
 * @group Models
 */
interface Port {
  port: string;
  compass: Compass;
}
/**
 * Model that can be converted to Node in DOT language.
 * @group Models
 */
interface NodeModel extends HasComment, HasAttributes<NodeAttributeKey>, DotObjectModel<'Node'> {
  /** ID of the node */
  readonly id: string;
  /** Returns ForwardRefNode with port and compass specified. */
  port(port: string | Partial<Port>): ForwardRefNode;
}
/**
 * Model that can be converted to Edge in DOT language.
 * @group Models
 */
interface EdgeModel extends HasComment, HasAttributes<EdgeAttributeKey>, DotObjectModel<'Edge'> {
  readonly targets: EdgeTargetTuple;
}
/**
 * Cluster common attribute interface.
 * @group Models
 */
interface GraphCommonAttributes {
  /** Manage common attributes of graphs in a graph. */
  graph: AttributeListModel<'Graph', SubgraphAttributeKey | ClusterSubgraphAttributeKey>;
  /** Manage common attributes of edges in a graph. */
  edge: AttributeListModel<'Edge', EdgeAttributeKey>;
  /** Manage common attributes of nodes in a graph. */
  node: AttributeListModel<'Node', NodeAttributeKey>;
}
/**
 * DOT model representing a graph/digraph/subgraph.
 * @group Models
 */
interface GraphBaseModel<T extends AttributeKey = AttributeKey> extends HasComment, Attributes<T> {
  readonly id?: string;
  readonly attributes: Readonly<GraphCommonAttributes>;
  /** Node objects in the graph. */
  readonly nodes: ReadonlyArray<NodeModel>;
  /** Edge objects in the graph. */
  readonly edges: ReadonlyArray<EdgeModel>;
  /** Subgraph objects in the graph. */
  readonly subgraphs: ReadonlyArray<SubgraphModel>;
  /**
   * @beta
   */
  with(models: Partial<ModelsContext>): void;
  /**
   * Add a Node to the graph.
   */
  addNode(node: NodeModel): void;
  /**
   * Add Edge to the graph.
   */
  addEdge(edge: EdgeModel): void;
  /**
   * Add a Subgraph to the graph.
   */
  addSubgraph(subgraph: SubgraphModel): void;
  /**
   * Check if the Node exists in the graph.
   */
  existNode(nodeId: string): boolean;
  /**
   * Check if the Edge exists in the graph.
   */
  existEdge(edge: EdgeModel): boolean;
  /**
   * Check if the Subgraph exists in the graph.
   */
  existSubgraph(subgraph: SubgraphModel): boolean;
  /**
   * Remove Node from the graph.
   */
  removeNode(node: NodeModel | string): void;
  /**
   * Remove Edge from the graph.
   */
  removeEdge(edge: EdgeModel): void;
  /**
   * Remove Subgraph from the graph.
   */
  removeSubgraph(subgraph: SubgraphModel): void;
  /**
   * Create a Node in the graph.
   */
  createNode(id: string, attributes?: NodeAttributesObject): NodeModel;
  /**
   * Create a Subgraph and add it to the graph.
   *
   * @param id - Subgraph ID
   * @param attributes - Subgraph attribute object
   */
  createSubgraph(id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;
  createSubgraph(attributes?: SubgraphAttributesObject): SubgraphModel;
  /**
   * Get Subgraph in cluster by specifying id.
   *
   * If there is no Subgraph with the specified id in the graph, return undefined.
   */
  getSubgraph(id: string): SubgraphModel | undefined;
  /**
   * Get Node in cluster by specifying id.
   *
   * @description
   * If there is no Node with the specified id in the graph, return undefined.
   */
  getNode(id: string): NodeModel | undefined;
  /** Create Edge and add it to the graph. */
  createEdge(targets: EdgeTargetLikeTuple, attributes?: EdgeAttributesObject): EdgeModel;
  /**
   * Create a subgraph by specifying its id (or get it if it already exists).
   *
   * By specifying a callback function, the target subgraph can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a cluster with id as A.
   *   g.subgraph('A', (A) => {
   *     // Create a node with id as A1 in cluster A.
   *     A.node('A1');
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   subgraph "A" {
   * //     "A1";
   * //   }
   * // }
   * ```
   *
   * @param id Subgraph ID.
   * @param callback Callbacks for manipulating created or retrieved subgraph.
   */
  subgraph(id: string, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;
  /**
   * Create a subgraph (or get one if it already exists) and adapt the attributes.
   *
   * By specifying a callback function, the target subgraph can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a cluster with id as A and specifying its attributes.
   *   g.subgraph('A', { [attribute.color]: 'red', [attribute.label]: 'my label' }, (A) => {
   *     // Create a node with id as A1 in cluster A.
   *     A.node('A1');
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   subgraph "A" {
   * //     color = "red";
   * //     label = "my label";
   * //     "A1";
   * //   }
   * // }
   * ```
   *
   * @param id  Subgraph ID.
   * @param attributes Object of attributes to be adapted to the subgraph.
   * @param callback Callbacks for manipulating created or retrieved subgraph.
   */
  subgraph(
    id: string,
    attributes: SubgraphAttributesObject,
    callback?: (subgraph: SubgraphModel) => void,
  ): SubgraphModel;
  /**
   * Create anonymous subgraphs and and adapt the attributes.
   *
   * By specifying a callback function, the target subgraph can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a anonymous cluster and specifying its attributes.
   *   g.subgraph({ [attribute.color]: 'red', [attribute.label]: 'my label' }, (A) => {
   *     // Create a node with id as A1 in anonymous cluster.
   *     A.node('A1');
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   subgraph {
   * //     color = "red";
   * //     label = "my label";
   * //     "A1";
   * //   }
   * // }
   * ```
   *
   * @param attributes Object of attributes to be adapted to the subgraph.
   * @param callback Callbacks for manipulating created or retrieved subgraph.
   */
  subgraph(attributes: SubgraphAttributesObject, callback?: (subgraph: SubgraphModel) => void): SubgraphModel;
  /**
   * Create anonymous subgraphs and manipulate them with callback functions.
   *
   * By specifying a callback function, the target subgraph can be received and manipulated as an argument.
   *
   * @param callback Callbacks for manipulating created or retrieved subgraph.
   */
  subgraph(callback?: (subgraph: SubgraphModel) => void): SubgraphModel;
  /**
   * Create a node by specifying its id (or get it if it already exists).
   *
   * By specifying a callback function, the target node can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a node with id as A.
   *   g.node('A');
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   "A";
   * // }
   * ```
   *
   * @param id Node ID.
   * @param callback Callbacks for manipulating created or retrieved node.
   */
  node(id: string, callback?: (node: NodeModel) => void): NodeModel;
  /**
   * Create a node (or get one if it already exists) and adapt the attributes.
   *
   * By specifying a callback function, the target node can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a node by specifying its id and specifying its attributes.
   *   g.node('A', {
   *     [attribute.color]: 'red',
   *     [attribute.label]: 'my label',
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   "A" [
   * //     color = "red",
   * //     label = "my label",
   * //   ];
   * // }
   * ```
   *
   * @param id Node ID.
   * @param attributes Object of attributes to be adapted to the node.
   * @param callback Callbacks for manipulating created or retrieved node.
   */
  node(id: string, attributes: NodeAttributesObject, callback?: (node: NodeModel) => void): NodeModel;
  /**
   * Set a common attribute for the nodes in the graph.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Set a common attribute for the nodes in the graph.
   *   g.node({
   *     [attribute.color]: 'red',
   *     [attribute.label]: 'my label',
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   node [
   * //     color = "red",
   * //     label = "my label",
   * //   ];
   * // }
   * ```
   *
   * @param attributes Object of attributes to be adapted to the nodes.
   */
  node(attributes: NodeAttributesObject): void;
  /**
   * Create a edge.
   *
   * By specifying a callback function, the target edge can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a edge.
   *   g.edge(['a', 'b']);
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   "a" -> "b";
   * // }
   * ```
   * @param targets Nodes.
   * @param callback Callbacks for manipulating created or retrieved edge.
   */
  edge(targets: EdgeTargetLikeTuple, callback?: (edge: EdgeModel) => void): EdgeModel;
  /**
   * Create a edge and adapt the attributes.
   *
   * By specifying a callback function, the target edge can be received and manipulated as an argument.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Create a edge and specifying its attributes.
   *   g.edge(['a', 'b'], {
   *     [attribute.color]: 'red',
   *     [attribute.label]: 'my label',
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   "a" -> "b" [
   * //     color = "red",
   * //     label = "my label",
   * //   ];
   * // }
   * ```
   *
   * @param attributes Object of attributes to be adapted to the edge.
   * @param callback Callbacks for manipulating created or retrieved edge.
   */
  edge(targets: EdgeTargetLikeTuple, attributes: EdgeAttributesObject, callback?: (edge: EdgeModel) => void): EdgeModel;
  /**
   * Set a common attribute for the edges in the graph.
   *
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   // Set a common attribute for the edges in the graph.
   *   g.edge({
   *     [attribute.color]: 'red',
   *     [attribute.label]: 'my label',
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   edge [
   * //     color = "red",
   * //     label = "my label",
   * //   ];
   * // }
   * ```
   * @param attributes Object of attributes to be adapted to the edges.
   */
  edge(attributes: EdgeAttributesObject): void;
  /**
   * Set a common attribute for the graph in the graph.
   *
   * ```ts
   * const G = digraph('G', (g) => {
   *   g.graph({
   *     [attribute.color]: 'red',
   *     [attribute.label]: 'my label',
   *   });
   * });
   *
   * console.log(toDot(G));
   * // digraph "G" {
   * //   graph [
   * //     color = "red",
   * //     label = "my label",
   * //   ];
   * // }
   * ```
   * @param attributes Object of attributes to be adapted to the graph.
   */
  graph(attributes: SubgraphAttributesObject): void;
}
/**
 * DOT model representing a subgraph.
 * @group Models
 */
interface SubgraphModel
  extends GraphBaseModel<SubgraphAttributeKey | ClusterSubgraphAttributeKey>,
    DotObjectModel<'Subgraph'> {
  /** Determines whether the Subgraph is a SubgraphCluster. */
  isSubgraphCluster(): boolean;
}
/**
 * DOT model representing a root graphs(digraph and graph).
 * @group Models
 */
interface RootGraphModel extends GraphBaseModel<GraphAttributeKey>, DotObjectModel<'Graph'> {
  directed: boolean;
  /**
   * Strict mode.
   *
   * @description
   * A graph may also be described as strict.
   * This forbids the creation of multi-edges, i.e., there can be at most one edge with a given tail node and head node in the directed case.
   * For undirected graphs, there can be at most one edge connected to the same two nodes.
   * Subsequent edge statements using the same two nodes will identify the edge with the previously defined one and apply any attributes given in the edge statement.
   */
  strict: boolean;
}
/**
 * @group Models
 * @beta
 */
interface RootGraphConstructor {
  new (id?: string, attributes?: GraphAttributesObject): RootGraphModel;
  new (id?: string, strict?: boolean, attributes?: GraphAttributesObject): RootGraphModel;
  new (strict?: boolean, attributes?: GraphAttributesObject): RootGraphModel;
  new (attributes?: GraphAttributesObject): RootGraphModel;
  new (...args: any[]): RootGraphModel;
}
/**
 * @group Models
 * @beta
 */
interface SubgraphConstructor {
  new (id?: string, attributes?: SubgraphAttributesObject): SubgraphModel;
  new (attributes?: SubgraphAttributesObject): SubgraphModel;
  new (...args: any[]): SubgraphModel;
}
/**
 * @group Models
 * @beta
 */
interface NodeConstructor {
  new (id: string, attributes?: NodeAttributesObject): NodeModel;
  new (...args: any[]): NodeModel;
}
/**
 * @group Models
 * @beta
 */
interface EdgeConstructor {
  new (targets: EdgeTargetTuple, attributes?: EdgeAttributesObject): EdgeModel;
  new (...args: any[]): EdgeModel;
}
/** @hidden */
declare function isForwardRefNode(object: unknown): object is ForwardRefNode;
/** @hidden */
declare function isNodeModel(object: unknown): object is NodeModel;
/** @hidden */
declare function isNodeRef(node: unknown): node is NodeRef;
/** @hidden */
declare function isNodeRefLike(node: unknown): node is NodeRefLike;
/** @hidden */
declare function isNodeRefGroupLike(target: NodeRefLike | NodeRefGroupLike): target is NodeRefGroupLike;
/** @hidden */
declare function isCompass(c: string): c is Compass;
/** @hidden */
declare function toNodeRef(target: NodeRefLike): NodeRef;
/** @hidden */
declare function toNodeRefGroup(targets: NodeRefGroupLike): NodeRefGroup;

export {
  ASTType,
  AddDouble,
  AddPoint,
  ArrowType,
  Attribute,
  AttributeKey,
  AttributeListKind,
  AttributeListModel,
  AttributeValue,
  Attributes,
  AttributesEntities,
  AttributesGroupModel,
  AttributesObject,
  Blank,
  ClusterMode,
  ClusterSubgraphAttributeKey,
  Color,
  ColorList,
  Compass,
  DirType,
  DotObjectModel,
  DotObjectType,
  Double,
  DoubleList,
  EdgeAttributeKey,
  EdgeAttributesObject,
  EdgeConstructor,
  EdgeModel,
  EdgeTarget,
  EdgeTargetLike,
  EdgeTargetLikeTuple,
  EdgeTargetTuple,
  EscString,
  ForwardRefNode,
  GraphAttributeKey,
  GraphAttributesObject,
  GraphBaseModel,
  GraphCommonAttributes,
  HTMLLikeLabel,
  HasAttributes,
  HasComment,
  Int,
  LayerList,
  LayerRange,
  LblString,
  ModelsContext,
  NodeAttributeKey,
  NodeAttributesObject,
  NodeConstructor,
  NodeModel,
  NodeRef,
  NodeRefGroup,
  NodeRefGroupLike,
  NodeRefLike,
  OutputMode,
  PackMode,
  Pagedir,
  Point,
  PointList,
  Port,
  PortPos,
  QuadType,
  RankType,
  Rankdir,
  Rect,
  RootGraphConstructor,
  RootGraphModel,
  RootModelsContext,
  Shape,
  SmoothType,
  SplineType,
  StartType,
  Style,
  SubgraphAttributeKey,
  SubgraphAttributesObject,
  SubgraphConstructor,
  SubgraphModel,
  ViewPort,
  createModelsContext,
  isCompass,
  isForwardRefNode,
  isNodeModel,
  isNodeRef,
  isNodeRefGroupLike,
  isNodeRefLike,
  toNodeRef,
  toNodeRefGroup,
};
