"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FEDERATION_VERSIONS = exports.FederationSpecDefinition = exports.FEDERATION1_DIRECTIVES = exports.FEDERATION1_TYPES = exports.FederationDirectiveName = exports.FederationTypeName = exports.federationIdentity = void 0;
const definitions_1 = require("./definitions");
const coreSpec_1 = require("./coreSpec");
const directiveAndTypeSpecification_1 = require("./directiveAndTypeSpecification");
const graphql_1 = require("graphql");
const utils_1 = require("./utils");
const tagSpec_1 = require("./tagSpec");
const federation_1 = require("./federation");
const knownCoreFeatures_1 = require("./knownCoreFeatures");
const inaccessibleSpec_1 = require("./inaccessibleSpec");
exports.federationIdentity = 'https://specs.apollo.dev/federation';
var FederationTypeName;
(function (FederationTypeName) {
    FederationTypeName["FIELD_SET"] = "FieldSet";
})(FederationTypeName = exports.FederationTypeName || (exports.FederationTypeName = {}));
var FederationDirectiveName;
(function (FederationDirectiveName) {
    FederationDirectiveName["KEY"] = "key";
    FederationDirectiveName["EXTERNAL"] = "external";
    FederationDirectiveName["REQUIRES"] = "requires";
    FederationDirectiveName["PROVIDES"] = "provides";
    FederationDirectiveName["EXTENDS"] = "extends";
    FederationDirectiveName["SHAREABLE"] = "shareable";
    FederationDirectiveName["OVERRIDE"] = "override";
    FederationDirectiveName["TAG"] = "tag";
    FederationDirectiveName["INACCESSIBLE"] = "inaccessible";
    FederationDirectiveName["COMPOSE_DIRECTIVE"] = "composeDirective";
    FederationDirectiveName["INTERFACE_OBJECT"] = "interfaceObject";
})(FederationDirectiveName = exports.FederationDirectiveName || (exports.FederationDirectiveName = {}));
const fieldSetTypeSpec = (0, directiveAndTypeSpecification_1.createScalarTypeSpecification)({ name: FederationTypeName.FIELD_SET });
const keyDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: FederationDirectiveName.KEY,
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
    repeatable: true,
    argumentFct: (schema) => ({
        args: [
            fieldsArgument(schema),
            { name: 'resolvable', type: schema.booleanType(), defaultValue: true },
        ],
        errors: [],
    }),
});
const extendsDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: FederationDirectiveName.EXTENDS,
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.INTERFACE],
});
const externalDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: FederationDirectiveName.EXTERNAL,
    locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [{ name: 'reason', type: schema.stringType() }],
        errors: [],
    }),
});
const requiresDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: FederationDirectiveName.REQUIRES,
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [fieldsArgument(schema)],
        errors: [],
    }),
});
const providesDirectiveSpec = (0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
    name: FederationDirectiveName.PROVIDES,
    locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
    argumentFct: (schema) => ({
        args: [fieldsArgument(schema)],
        errors: [],
    }),
});
const legacyFederationTypes = [
    fieldSetTypeSpec,
];
const legacyFederationDirectives = [
    keyDirectiveSpec,
    requiresDirectiveSpec,
    providesDirectiveSpec,
    externalDirectiveSpec,
    tagSpec_1.TAG_VERSIONS.find(new coreSpec_1.FeatureVersion(0, 2)).tagDirectiveSpec,
    extendsDirectiveSpec,
];
exports.FEDERATION1_TYPES = legacyFederationTypes;
exports.FEDERATION1_DIRECTIVES = legacyFederationDirectives;
function fieldsArgument(schema) {
    return { name: 'fields', type: fieldSetType(schema) };
}
function fieldSetType(schema) {
    const metadata = (0, federation_1.federationMetadata)(schema);
    (0, utils_1.assert)(metadata, `The schema is not a federation subgraph`);
    return new definitions_1.NonNullType(metadata.fieldSetType());
}
class FederationSpecDefinition extends coreSpec_1.FeatureDefinition {
    constructor(version) {
        super(new coreSpec_1.FeatureUrl(exports.federationIdentity, 'federation', version));
        this._directiveSpecs = new utils_1.MapWithCachedArrays();
        this._typeSpecs = new utils_1.MapWithCachedArrays();
        for (const type of legacyFederationTypes) {
            this.registerType(type);
        }
        for (const directive of legacyFederationDirectives) {
            this.registerDirective(directive);
        }
        this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
            name: FederationDirectiveName.SHAREABLE,
            locations: [graphql_1.DirectiveLocation.OBJECT, graphql_1.DirectiveLocation.FIELD_DEFINITION],
            repeatable: version >= (new coreSpec_1.FeatureVersion(2, 2)),
        }));
        this.registerDirective(inaccessibleSpec_1.INACCESSIBLE_VERSIONS.latest().inaccessibleDirectiveSpec);
        this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
            name: FederationDirectiveName.OVERRIDE,
            locations: [graphql_1.DirectiveLocation.FIELD_DEFINITION],
            argumentFct: (schema) => ({
                args: [{ name: 'from', type: new definitions_1.NonNullType(schema.stringType()) }],
                errors: [],
            }),
        }));
        if (version >= (new coreSpec_1.FeatureVersion(2, 1))) {
            this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
                name: FederationDirectiveName.COMPOSE_DIRECTIVE,
                locations: [graphql_1.DirectiveLocation.SCHEMA],
                repeatable: true,
                argumentFct: (schema) => ({
                    args: [{ name: 'name', type: schema.stringType() }],
                    errors: [],
                }),
            }));
        }
        if (version >= (new coreSpec_1.FeatureVersion(2, 3))) {
            this.registerDirective((0, directiveAndTypeSpecification_1.createDirectiveSpecification)({
                name: FederationDirectiveName.INTERFACE_OBJECT,
                locations: [graphql_1.DirectiveLocation.OBJECT],
            }));
            this.registerDirective(tagSpec_1.TAG_VERSIONS.find(new coreSpec_1.FeatureVersion(0, 3)).tagDirectiveSpec);
        }
    }
    registerDirective(spec) {
        this._directiveSpecs.set(spec.name, spec);
    }
    registerType(spec) {
        this._typeSpecs.set(spec.name, spec);
    }
    directiveSpecs() {
        return this._directiveSpecs.values();
    }
    typeSpecs() {
        return this._typeSpecs.values();
    }
    addElementsToSchema(schema) {
        const feature = this.featureInSchema(schema);
        (0, utils_1.assert)(feature, 'The federation specification should have been added to the schema before this is called');
        let errors = [];
        for (const type of this.typeSpecs()) {
            errors = errors.concat(this.addTypeSpec(schema, type));
        }
        for (const directive of this.directiveSpecs()) {
            errors = errors.concat(this.addDirectiveSpec(schema, directive));
        }
        return errors;
    }
    allElementNames() {
        return this.directiveSpecs().map((spec) => `@${spec.name}`)
            .concat(this.typeSpecs().map((spec) => spec.name));
    }
}
exports.FederationSpecDefinition = FederationSpecDefinition;
exports.FEDERATION_VERSIONS = new coreSpec_1.FeatureDefinitions(exports.federationIdentity)
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 0)))
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 1)))
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 2)))
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 3)))
    .add(new FederationSpecDefinition(new coreSpec_1.FeatureVersion(2, 4)));
(0, knownCoreFeatures_1.registerKnownFeature)(exports.FEDERATION_VERSIONS);
//# sourceMappingURL=federationSpec.js.map